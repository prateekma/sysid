// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

#include "sysid/deploy/RomiSession.h"

#include <mutex>
#include <system_error>

#include <fmt/format.h>
#include <uv.h>
#include <wpi/StringRef.h>
#include <wpi/fs.h>
#include <wpi/raw_ostream.h>
#include <wpi/uv/Buffer.h>
#include <wpi/uv/Pipe.h>
#include <wpi/uv/Process.h>

#include "sysid/Util.h"

#define INFO(x) WPI_INFO(m_logger, x)
#define DEBUG(x) WPI_DEBUG(m_logger, x)
#define ERROR(x) WPI_ERROR(m_logger, x)

using namespace sysid;

// This is auto-generated by the build system.
namespace sysid {
std::string_view GetResource_frcUserProgramRomi_out();
}  // namespace sysid

// Lock for Execute(). Only one instance of Execute() should be running at a
// time (even across separate instances).
static wpi::mutex s_mutex;

void RomiSession::Execute(wpi::uv::Loop& lp) {
  // Lock mutex.
  std::scoped_lock lock{s_mutex};

  // Choose the location where we should extract the Romi executable.
  auto exe = fs::temp_directory_path() / fmt::format("romi{}", EXE_EXT);

  // Write to the executable there.
  sysid::SaveFile(sysid::GetResource_frcUserProgramRomi_out(), exe);
  DEBUG(fmt::format("Saved {}", exe.string()));

  // Set executable permissions.
  fs::permissions(exe, fs::perms::owner_all);

  // Create Romi stdout pipe.
  m_stdoutPipe = wpi::uv::Pipe::Create(lp);
  m_stdoutPipe->data.connect([this](wpi::uv::Buffer& buf, size_t n) {
    INFO(std::string_view(buf.data().data(), n));
  });

  // Create options for launching process.
  auto env = wpi::uv::Process::Env("HALSIMWS_HOST=10.0.0.2");
  auto pipe =
      wpi::uv::Process::StdioCreatePipe(1, *m_stdoutPipe, UV_WRITABLE_PIPE);

  // Launch process.
  auto process = wpi::uv::Process::Spawn(lp, exe.string(), env, pipe);
  if (!process) {
    ERROR("Could not launch Romi process.");
    m_exitCode = -1;
    return;
  }

  m_stdoutPipe->StartRead();

  // Set on-process-exit handler.
  process->exited.connect([this](int64_t exitCode, int signal) {
    // Set exit code local variable.
    m_exitCode = exitCode;

    // Close pipe.
    m_stdoutPipe->StopRead();
    m_stdoutPipe->Close();

    // Log debug info.
    DEBUG(fmt::format("Romi process exited with {}.", exitCode));
  });
}

void RomiSession::Kill() {
  if (m_process) {
    m_process->Kill(9);
  }
}

RomiSession::Status RomiSession::GetStatus() const {
  // Check if we have an exit code.
  if (m_exitCode) {
    // If the exit code is not 0, then we had a failure.
    return m_exitCode == 0 ? Status::kSuccess : Status::kFailure;
  }

  // If not, then we are in progress.
  return Status::kInProgress;
}
